import { useState, useEffect, useCallback, useRef } from 'react';
import { 
  onSnapshot, 
  collection, 
  query, 
  where, 
  orderBy, 
  Timestamp,
  limit 
} from 'firebase/firestore';
import { db } from '@/lib/firebase';
import { Order, OrderStatus } from '@/types';
import { toast } from 'react-hot-toast';
import { PushNotificationService } from '@/services/pushNotificationService';
import { useAuth } from '@/hooks/useAuth';

// Bildirim t√ºrleri
export interface Notification {
  id: string;
  type: 'new_order' | 'status_update' | 'payment' | 'system';
  title: string;
  message: string;
  orderId?: string;
  read: boolean;
  createdAt: Date;
  data?: any;
}

// Hook return tipi
export interface NotificationHook {
  notifications: Notification[];
  unreadCount: number;
  markAsRead: (id: string) => void;
  markAllAsRead: () => void;
  clearNotifications: () => void;
}

// Admin i√ßin t√ºm sipari≈ü bildirimlerini dinle
export function useAdminNotifications(): NotificationHook {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const isInitializedRef = useRef(false);
  const lastOrderTimestampRef = useRef<Date | null>(null);
  const { user } = useAuth();

  useEffect(() => {
    // Kullanƒ±cƒ± admin deƒüilse √ßalƒ±≈üma
    if (!user?.isAdmin) {
      return;
    }

    // Sadece admin panelinde bildirim g√∂ster - g√º√ßlendirilmi≈ü kontrol
    const isAdminPage = typeof window !== 'undefined' && 
                       (window.location.pathname.startsWith('/admin') || 
                        window.location.pathname === '/admin');
    
    if (!isAdminPage) {
      return;
    }

    // Push notification izni iste
    PushNotificationService.requestPermission();

    // Yeni sipari≈üleri dinle
    const ordersQuery = query(
      collection(db, 'orders'),
      orderBy('createdAt', 'desc'),
      limit(20)
    );

    const unsubscribe = onSnapshot(ordersQuery, (snapshot) => {
      // ƒ∞lk y√ºkleme - sadece timestamp'i kaydet, bildirim g√∂sterme
      if (!isInitializedRef.current) {
        isInitializedRef.current = true;
        
        // En son sipari≈ü zamanƒ±nƒ± kaydet
        if (!snapshot.empty) {
          const latestOrder = snapshot.docs[0].data();
          lastOrderTimestampRef.current = latestOrder.createdAt?.toDate() || new Date();
        }
        
        return;
      }

      // Sadece yeni eklenen sipari≈üler i√ßin bildirim g√∂ster
      snapshot.docChanges().forEach((change) => {
        const order = { id: change.doc.id, ...change.doc.data() } as Order & { id: string };
        
        // Firestore Timestamp'i Date'e √ßevir
        let orderCreatedAt: Date;
        const createdAtField = order.createdAt as any;
        
        if (createdAtField && typeof createdAtField.toDate === 'function') {
          // Firestore Timestamp
          orderCreatedAt = createdAtField.toDate();
        } else if (createdAtField instanceof Date) {
          // Zaten Date
          orderCreatedAt = createdAtField;
        } else {
          // Fallback
          orderCreatedAt = new Date();
        }

        if (change.type === 'added') {
          // Sadece son bilinen sipari≈ü zamanƒ±ndan sonraki sipari≈üleri bildir
          if (lastOrderTimestampRef.current && orderCreatedAt <= lastOrderTimestampRef.current) {
            return; // Eski sipari≈ü, bildirim g√∂sterme
          }
          
          // Yeni sipari≈ü bildirimi
          const notification: Notification = {
            id: `new-order-${order.id}`,
            type: 'new_order',
            title: 'Yeni Sipari≈ü',
            message: `Yeni sipari≈ü alƒ±ndƒ±: #${order.id.slice(-8)}`,
            orderId: order.id,
            read: false,
            createdAt: new Date(),
            data: order
          };

          setNotifications(prev => [notification, ...prev]);
          
          // Toast bildirimi
          toast.success(`üîî Yeni sipari≈ü: #${order.id.slice(-8)}`, {
            icon: 'üîî',
            duration: 4000
          });

          // Browser push notification
          PushNotificationService.sendAdminNotification({
            title: 'Yeni Sipari≈ü Alƒ±ndƒ±',
            message: `Sipari≈ü #${order.id.slice(-8)} - ${order.total} TL`,
            type: 'order',
            url: `/admin/orders/${order.id}`
          });

          // Bildirim sesi
          PushNotificationService.playNotificationSound('order');

          // Son sipari≈ü zamanƒ±nƒ± g√ºncelle
          lastOrderTimestampRef.current = orderCreatedAt;
        }

        if (change.type === 'modified') {
          // Sipari≈ü durumu g√ºncelleme bildirimi (daha az agresif)
          const notification: Notification = {
            id: `status-${order.id}-${Date.now()}`,
            type: 'status_update',
            title: 'Sipari≈ü Durumu G√ºncellendi',
            message: `Sipari≈ü #${order.id.slice(-8)} durumu g√ºncellendi`,
            orderId: order.id,
            read: false,
            createdAt: new Date(),
            data: order
          };

          setNotifications(prev => [notification, ...prev]);
        }
      });
    });

    return () => unsubscribe();
  }, [user?.isAdmin]); // Sadece admin durumu deƒüi≈ütiƒüinde yeniden √ßalƒ±≈ütƒ±r

  // Bildirimi okundu olarak i≈üaretle
  const markAsRead = (id: string) => {
    setNotifications(prev => 
      prev.map(notification => 
        notification.id === id 
          ? { ...notification, read: true }
          : notification
      )
    );
  };

  // T√ºm bildirimleri okundu olarak i≈üaretle
  const markAllAsRead = () => {
    setNotifications(prev => 
      prev.map(notification => ({ ...notification, read: true }))
    );
  };

  // Bildirimleri temizle
  const clearNotifications = () => {
    setNotifications([]);
  };

  const unreadCount = notifications.filter(n => !n.read).length;

  return {
    notifications,
    unreadCount,
    markAsRead,
    markAllAsRead,
    clearNotifications
  };
}

// Restoran i√ßin sipari≈ü bildirimlerini dinle
export function useRestaurantNotifications(restaurantId: string): NotificationHook {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const isInitializedRef = useRef(false);
  const lastOrderTimestampRef = useRef<Date | null>(null);

  useEffect(() => {
    if (!restaurantId) return;

    // Sadece restoran panelinde bildirim g√∂ster
    const isRestaurantPage = typeof window !== 'undefined' && window.location.pathname.startsWith('/restaurant');
    
    if (!isRestaurantPage) {
      return;
    }

    // Push notification izni iste
    PushNotificationService.requestPermission();

    // Restoran sipari≈ülerini dinle
    const ordersQuery = query(
      collection(db, 'orders'),
      where('restaurantId', '==', restaurantId),
      orderBy('createdAt', 'desc'),
      limit(20)
    );

    const unsubscribe = onSnapshot(ordersQuery, (snapshot) => {
      // ƒ∞lk y√ºkleme - sadece timestamp'i kaydet, bildirim g√∂sterme
      if (!isInitializedRef.current) {
        isInitializedRef.current = true;
        
        // En son sipari≈ü zamanƒ±nƒ± kaydet
        if (!snapshot.empty) {
          const latestOrder = snapshot.docs[0].data();
          const createdAtField = latestOrder.createdAt as any;
          if (createdAtField && typeof createdAtField.toDate === 'function') {
            lastOrderTimestampRef.current = createdAtField.toDate();
          } else {
            lastOrderTimestampRef.current = new Date();
          }
        }
        
        return;
      }

      snapshot.docChanges().forEach((change) => {
        const order = { id: change.doc.id, ...change.doc.data() } as Order & { id: string };

        if (change.type === 'added') {
          // Firestore Timestamp'i Date'e √ßevir
          let orderCreatedAt: Date;
          const createdAtField = order.createdAt as any;
          
          if (createdAtField && typeof createdAtField.toDate === 'function') {
            orderCreatedAt = createdAtField.toDate();
          } else if (createdAtField instanceof Date) {
            orderCreatedAt = createdAtField;
          } else {
            orderCreatedAt = new Date();
          }

          // Sadece son bilinen sipari≈ü zamanƒ±ndan sonraki sipari≈üleri bildir
          if (lastOrderTimestampRef.current && orderCreatedAt <= lastOrderTimestampRef.current) {
            return; // Eski sipari≈ü, bildirim g√∂sterme
          }

          // Yeni sipari≈ü bildirimi
          const notification: Notification = {
            id: `new-order-${order.id}`,
            type: 'new_order',
            title: 'Yeni Sipari≈ü Aldƒ±nƒ±z!',
            message: `Sipari≈ü #${order.id.slice(-8)} - ${order.total} TL`,
            orderId: order.id,
            read: false,
            createdAt: new Date(),
            data: order
          };

          setNotifications(prev => [notification, ...prev]);
          
          // Toast bildirimi
          toast.success(`Yeni sipari≈ü alƒ±ndƒ±! #${order.id.slice(-8)}`, {
            icon: 'üçΩÔ∏è',
            duration: 5000
          });

          // Browser push notification
          PushNotificationService.sendOrderNotification({
            orderId: order.id,
            customerName: order.user?.displayName || 'M√º≈üteri',
            total: order.total,
            items: order.items
          });

          // Bildirim sesi
          PushNotificationService.playNotificationSound('order');

          // Son sipari≈ü zamanƒ±nƒ± g√ºncelle
          lastOrderTimestampRef.current = orderCreatedAt;
        }

        if (change.type === 'modified') {
          // Sipari≈ü g√ºncelleme bildirimi (daha az agresif)
          const notification: Notification = {
            id: `update-${order.id}-${Date.now()}`,
            type: 'status_update',
            title: 'Sipari≈ü G√ºncellendi',
            message: `Sipari≈ü #${order.id.slice(-8)} g√ºncellendi`,
            orderId: order.id,
            read: false,
            createdAt: new Date(),
            data: order
          };

          setNotifications(prev => [notification, ...prev]);
        }
      });
    });

    return () => unsubscribe();
  }, [restaurantId]);

  const markAsRead = useCallback((id: string) => {
    setNotifications(prev => 
      prev.map(notif => 
        notif.id === id ? { ...notif, read: true } : notif
      )
    );
  }, []);

  const markAllAsRead = useCallback(() => {
    setNotifications(prev => 
      prev.map(notif => ({ ...notif, read: true }))
    );
  }, []);

  const clearNotifications = useCallback(() => {
    setNotifications([]);
  }, []);

  const unreadCount = notifications.filter(n => !n.read).length;

  return {
    notifications,
    unreadCount,
    markAsRead,
    markAllAsRead,
    clearNotifications
  };
}

// M√º≈üteri i√ßin sipari≈ü bildirimlerini dinle
export function useUserNotifications(userId: string): NotificationHook {
  const [notifications, setNotifications] = useState<Notification[]>([]);

  useEffect(() => {
    if (!userId) return;

    // Push notification izni iste
    PushNotificationService.requestPermission();

    // Kullanƒ±cƒ±nƒ±n sipari≈ülerini dinle
    const ordersQuery = query(
      collection(db, 'orders'),
      where('userId', '==', userId),
      orderBy('createdAt', 'desc'),
      limit(10)
    );

    const unsubscribe = onSnapshot(ordersQuery, (snapshot) => {
      snapshot.docChanges().forEach((change) => {
        const order = { id: change.doc.id, ...change.doc.data() } as Order & { id: string };

        if (change.type === 'modified') {
          // Sipari≈ü durumu deƒüi≈ütiƒüinde bildirim
          const statusText = getStatusText(order.status);
          
          const notification: Notification = {
            id: `status-${order.id}-${Date.now()}`,
            type: 'status_update',
            title: 'Sipari≈ü Durumu G√ºncellendi',
            message: `Sipari≈üiniz: ${statusText}`,
            orderId: order.id,
            read: false,
            createdAt: new Date(),
            data: order
          };

          setNotifications(prev => [notification, ...prev]);
          
          // Toast bildirimi
          toast.success(`Sipari≈üiniz ${statusText.toLowerCase()}`, {
            icon: getStatusIcon(order.status),
            duration: 4000
          });

          // Browser push notification
          PushNotificationService.sendOrderStatusNotification({
            orderId: order.id,
            status: statusText,
            restaurantName: 'NeYisek Restoran'
          });

          // Bildirim sesi
          PushNotificationService.playNotificationSound('status');
        }
      });
    });

    return () => unsubscribe();
  }, [userId]);

  const markAsRead = useCallback((id: string) => {
    setNotifications(prev => 
      prev.map(notif => 
        notif.id === id ? { ...notif, read: true } : notif
      )
    );
  }, []);

  const markAllAsRead = useCallback(() => {
    setNotifications(prev => 
      prev.map(notif => ({ ...notif, read: true }))
    );
  }, []);

  const clearNotifications = useCallback(() => {
    setNotifications([]);
  }, []);

  const unreadCount = notifications.filter(n => !n.read).length;

  return {
    notifications,
    unreadCount,
    markAsRead,
    markAllAsRead,
    clearNotifications
  };
}

// Yardƒ±mcƒ± fonksiyonlar
function getStatusText(status: OrderStatus): string {
  switch (status) {
    case OrderStatus.PENDING: return 'Bekliyor';
    case OrderStatus.CONFIRMED: return 'Onaylandƒ±';
    case OrderStatus.PREPARING: return 'Hazƒ±rlanƒ±yor';
    case OrderStatus.READY: return 'Hazƒ±r';
    case OrderStatus.DELIVERING: return 'Yolda';
    case OrderStatus.DELIVERED: return 'Teslim Edildi';
    case OrderStatus.CANCELLED: return 'ƒ∞ptal Edildi';
    default: return 'Bilinmiyor';
  }
}

function getStatusIcon(status: OrderStatus): string {
  switch (status) {
    case OrderStatus.PENDING: return '‚è≥';
    case OrderStatus.CONFIRMED: return '‚úÖ';
    case OrderStatus.PREPARING: return 'üë®‚Äçüç≥';
    case OrderStatus.READY: return 'üì¶';
    case OrderStatus.DELIVERING: return 'üöö';
    case OrderStatus.DELIVERED: return 'üéâ';
    case OrderStatus.CANCELLED: return '‚ùå';
    default: return 'üì±';
  }
} 